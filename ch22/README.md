# chap22. 維護

網站啟動之後：你就與分析、焦急地等待用戶的反應、在凌晨三點起床，查看網站是否還活著等事密不可分——它就像你孩子。

**規劃網站的維護**經常會受到冷眼相待。

## 維護的原則

### 有一個長期的規劃

如果你做好工作，客戶一定會樂於付費。但用戶端的**不**欣賞是無法預期的。

Internet的變遷很快，如果你使用最佳且最新的技術來建構網站，它可能會在短短的兩年之內變得搖搖欲墜。但它也可以持續長達7年，逐漸優雅地老化(這不常見！)。

估計網站的壽命，需要一些藝術、一些銷售技能，及一些科學。它的科學，涉及所有科學家都會做，就是**紀錄**。擁有一個良好的問題追蹤系統，以及維護詳細的紀錄，可讓你提供更良好(且更現實)的專案生命週期藍圖給客戶。

七年是對希望持續保持實用的網站，已經是最長的壽命了。

了解未來技術，也是藝術。如何誠實地建議客戶花更多錢，讓他們可以得到他的需要的價值。

### 使用原始碼控制

最大好處是找出原因：完全掌握何人在何時改變哪些東西。版本控制可了解專案的歷史，以及協助團隊合作的優秀工具之一。

### 使用問題追蹤器

問題追蹤器回歸到開發的科學。如果沒有一個系統化的方法來記錄專案的歷史，就不可能會有洞察力。如果你不知道你犯下什麼錯誤，又如何能夠避免再次犯錯？請紀錄所有的事情：每個客戶回報的缺陷，每一個你在客戶發現之前找到的缺陷，每一個客訴，每一個問題，每一個讚揚。紀錄修改花費的時間，誰修改它，涉及哪些Git提交，及誰批准那次修改。這裡的藝術是尋找不會讓這些事情過度浪費時間或繁重的工具。

### 養成良好的衛生習慣

版本控制、測試、程式碼審查及問題追蹤。

程式碼審查可以大大地促進衛生，因為**每個東西**都會被接觸，從討論問題追蹤系統的使用，包括問題起源於哪裡，到要添加的測試項目，到驗證修復，到版本控制提交意見。

### 不要拖延

你注意到你的團隊經常會花費大量的時間在每週的更新上面，但其實只要重新建構，就可以大幅改善。**當你在每個星期延遲重新建構時**，**就是在付出下一個星期的沒有效率的代價**。

越是拖延重新建構，**技術債務**就越沈重。但也不是老想要重新設計整個網站。

### 執行例行的QA檢查

你的每個網站都應該要有一個**文件化**的例行**QA**檢查。這個檢查應該包含連結檢查程式、HTML及CSS驗證，及執行你的測試項目。**文件化**可避免忽視檢查的項目，也可讓新成員更快進入狀況。

QA檢查清單：可讓你的非技術管理者信任你的團隊。也可與客戶分享，提醒他們購買了哪些服務，以及你正在追求他們的最大利益。

常態QA檢查，使用Google Webmaster Tools與Bing Webmaster Tools。他們可以給你非常重要的網站觀點：主要的搜尋引擎如何看待他。它會在你的robots.txt檔案中提醒你所有問題，包括會干擾搜尋結果的HTML問題、安全問題等等。

### 監視器分析

GA導入，你會看到細微的UX問題。是否有些網頁的流量不如你的預期？這可能代表你的導覽或促銷有問題，或是SEO問題。你的彈出率高嗎？這可能代表你的網站的內容需要調整。你的QA清單應該要附加一份分析清單(它也可以是QA清單的一部分)。該清單是**可變動的文件**。在網站的生命過程中，你或你的客戶可能會調整內容重要性的優先順序。

### 效能最佳化

這是一個快速變遷的世界，人們期望他們的內容可被快速地傳遞。效能調整的第一原則：先釐清，再最佳化。

可使用Google PageSpeed，它是一種測試網站效能的工具(現在PageSpeed已被記錄在Google Analytics，所以現在你可以監視效能趨勢)。

可列為週期性檢查效能(監視Google Analytics找出效能評分變化就夠了)。

### 優先追蹤潛在客戶

如果訪客對你的服務或產品有興趣的話，最強烈訊號就是給你聯絡資訊：你必須謹慎地看待這個資訊。你應該在QA清單中，例行性檢查會收集email或手機號碼的表單。

追蹤潛在客戶對網站的成功是如此關鍵，我建議你遵循以下五項原則收集資訊：

- **準備回退機制，以防JavaScript失效**

    針對收集客戶資料，準備AJAX失效的替代方案：表單提交。在你的<form>標籤裡面一定要有一個有效且可動作的action參數，就算你用的是AJAX。
    
    最好的方式是停用JavaScript來使用你的表單。

- **如果你使用AJAX，從表單的action參數取得URL**

    這可避免你不小心地忘記`<form>`標籤裡面的action參數。
    
    ```
    $('form').on('submit', function(evt) {
       evt.preventDefault();
       var action = $(this).attr('action');
       /* 執行AJAX提交 */
    })
    ```

- **至少提供一層的備份**

    怕外部存儲服務(or Campaign Monitor)故障，最好的做法是儲存潛在客戶外，也傳送一封email。如果你採取這種方式，就不應該使用個人的email地址，而是共用的email地址。你也應該要將潛在客戶存在備份資料庫。也應該要有個機制來提醒你發生故障。
    
- **如果所有的存儲都故障，就告知使用者**

    假如你有三層的備份：你的主要存儲是Campign Monitor，如果它故障，你會備份CSV檔並傳送一封email給dev@meadowlarktravel.com。如果所有管道都失效，你應該傳送訊息給使用者。請他稍後再試一次或直接與你聯絡。

- **檢查正面確認，而不是有沒有錯誤**

    發生錯誤，你經常會讓AJAX處理程式回傳一個內含err特性的物件，接著在用戶端程式碼中：

    ```
    if (data.err) {
        /* 告知使用者發生錯誤 */
    } else {
        /* 成功提交，感謝使用者 */
    }
    ```
    
    **請不要採取這種做法**。因如果AJAX處理程式中有錯誤，讓伺服器回應500或回應那不是一個有效的JSON，**這種做法就會默默地失敗**。相反地，提供一個success特性(只要有某個東西記錄使用者的資訊，你就要回傳success)。
    
    ```
    if (data.success) {
        /* 成功提交，感謝使用者 */
    } else {
        /* 告知使用者發生錯誤 */
    }
    ```

### 防止看不見的錯誤

記錄錯誤，開發人員因為忙永遠不會去檢查。這樣**你的網站的品質將會被忽略**。要預防此問題，首先你要採取的措施是提供一個簡單、標準的方法來記錄錯誤。將它**文件化**，不要讓它難以使用，不要讓它無法被發現。可公開一個meadowlarkLog函式，無論記錄存儲到哪裡，重點是他是標準的。當你完成紀錄機制，將它文件化，且團隊成員都知道它，請在你的QA清單中加入“檢查紀錄”，並說明怎麼檢查。

## 程式碼重複使用及重構

使用Node與Express開發，可有效對抗這個問題。Node帶來命名空間(模組)與套件(npm)，而Express帶來中介軟體的概念(透過Connect)。因為你有這些工具可以運用，你可更輕鬆開發可重複使用的程式碼。

### 私用npm註冊表

npm註冊表是一個儲存共用程式碼的好地方：畢竟它是設計npm的目的。除了簡單的存儲之外，你也可以版本控制，有一個方便的方式，可將這些套件加入其他的專案。

但它是完全開放原始碼的公用註冊表。

處理這種情況的方式之一，就是**私用npm註冊表**。設定私用npm註冊表或許是漸進的過程，但這是可做到的。

建立自己的私用註冊表最大的挑戰，就是目前npm無法讓你從多個存儲庫中拉出套件(只能公用或私用依賴關係)。npm團隊說它們沒有實作這個功能的資源，但有一些替代方案。

較佳的替代做法是提供一個代理伺服器給公用的npm，它會透過公用註冊表來傳遞公用套件的請求，並從它自己的資料庫中傳遞私用套件。有一種專案可以處理這件事：[Sinopia](https://github.com/rlidwka/sinopia)。

Sinopia非常容易安裝，而且它除了支援私用套件之外，也提供方便的私用快取供你機構使用。如果你選擇使用Sinopia，應該會發現到它使用在地檔案系統來存儲私用套件：你肯定想要將套件直接加到你的備份計畫裡面！Sinopia建議你在在地套件前面加上test-：如果你在為你的機構建立私用註冊表，我建議使用機構的名稱(meadowlark-)。

因為npm的設定只支援一個註冊表，當你“切換”成使用Sinopia時(使用`npm set registry`與`npm adduser`)，將無法使用公用的npm註冊表(除非透過Sinopia)。要回去使用公用的npm註冊表，你可以使用`npm set registry https://registry.npmjs.org/`或直接刪除檔案*~/.npmjs*。如果你想要將套件公開到公用註冊表，就必須做這件事。

較簡單的方式是使用一個託管的私用存儲。Nodejitsu與Gemfury都提供私用存儲。但這兩個服務都很貴。且只提供限制數量的套件

### 中介軟體

#### 模組直接公開中介軟體函式

如果你的中介軟體不須一個設定物件，就使用這個方法：

```
module.exports = function(req, res, next) {
    // 你的中介軟體放在這裡...記得呼叫next()
    // 或next('route')，除非這個中介軟體是終結點
    next();
}
```

這個中介軟體的使用方式：

```
var stuff = require('meadowlark-stuff');
app.use(stuff);
```

#### 模組公開一個回傳中介軟體的函式

如果你的中介軟體需要一個設定物件或其他資訊：

```
module.exports = function(config) {
    // 如果設定物件未被傳入
    // 通常會建立它
    if (!config) config = {};

    return function (req, res, next) {
        // 你的中介軟體放在這裡...記得呼叫next()
        // 或next('route')，除非這個中介軟體是終結點
        next();
    }
}
```

這個中介軟體的使用方式：

```
var stuff = require('meadowlark-stuff')({option: 'my choice'});

app.use(stuff);
```

#### 模組公開一個含有中介軟體的物件

如果你想要公開多個相關的中介軟體，就使用這方法：

```
module.exports = function(config) {
    // 如果設定物件未被傳入
    // 通常會建立它
    if (!config) config = {};

    return {
        m1: function (req, res, next) {
            // 你的中介軟體放在這裡...記得呼叫next()
            // 或next('route')，除非這個中介軟體是終結點
            next();
        },
        m2: function (req, res, next) {
            // 你的中介軟體放在這裡...記得呼叫next()
            // 或next('route')，除非這個中介軟體是終結點
            next();
        }
    }
}
```

這個中介軟體的使用方式：

```
var stuff = require('meadowlark-stuff')({option: 'my choice'});

app.use(stuff.m1);
app.use(stuff.m2);
```

#### 模組公開一個物件建構式

這或許是回傳中介軟體的方法中最罕見的一種，但如果你的中介軟體非常適合物件導向實作，這種方法會很實用。這也是最難實作中介軟體的方式，因為你會將中介軟體公開為一個實力方法，Express不會針對物件實例來呼叫它們，所以this將不會是你所期望的東西，如果你需要存取實例特性，見m2：

```
function Stuff(config) {
    this.config = config || {};
}
Stuff.prototype.m1 = function(req, res, next) {
    // 小心：'this'不是你所預期的東西，不要使用它
    next();
};
Stuff.prototype.m2 = function() {
    // 我們使用Function.prototype.bind來將這個實例與'this'特性結合
    return (function(req, res, next) {
        // 'this'將不會是Stuff實例
        next();
    }).bind(this);
};

module.exports = Stuff;
```

這個中介軟體的使用方式：

```
var Stuff = require('meadowlark-stuff');

var stuff = new Stuff({option: 'my choice'});

app.use(stuff.m1);
app.use(sstuff.m2());
```

## 結論

以啟用網站的熱情來擬定維護計畫，會讓網站持續擁有相同的體驗，讓顧客不斷回流。